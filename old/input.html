<html><head><title>1998 ACM East Central Programming Contest</title></head>
<body bgcolor="#f0f0ff">
<h1>1998 ACM East Central Programming Contest -- <br>Problem Input</h1>

<p>
<img alt="[logo]" src="input_files/ecr.gif">
<br><a href="http://plg.uwaterloo.ca/%7Eacm00/regional98/">Back to information on the whole contest</a>.
</p>

<hr>
<p>
This is our declaration of what we won't do to you.  Everything else is
fair game.  If we need to violate this for a problem, it will be explicitly
mentioned in the problem definition.  We would only do this if what we
were trying to accomplish in the problem did not violate the spirit in
which the the declaration was intended.
</p>
<h2>Kiss Your EOF Problems Goodbye</h2>
<p>

Waterloo teams are used to reading input from standard input and detecting
the end of file.  It isn't very hard.  However, this completely blew some
teams out of the water at previous regionals held at Waterloo.

</p><p>

At this contest you will still read from standard input, but we will be
nice about the input format.  Instead of specifying `read in a list of
integers and sort them', the first line in the file would contain an
integer that declared the number of integers to be read.  If there are
multiple test cases, the number of cases will be given or they
will be terminated by a sentinel value.  In general, we
will try to make input look like it did at the 1998 regional contest.

</p>
<h2>Lines Will Be at Most 80 Characters</h2>
<p>

<em>Actually, that isn't necessarily true.</em>  But if a question
requires input with lines that are longer than 80 characters, then the
problem statement will mention this.  So, if you are asked to read a
line containing several integers, there can't be more than 40 of them.

</p><p>

Note that the `80 characters' doesn't include the newline and ASCII NUL
characters that a C programmer would get using <tt>fgets()</tt>.  In
that case, a buffer of 82 characters would be necessary.  (Experienced
contestants don't calculate these numbers precisely.  Instead, they
automatically allow some slack and allocate buffers of size 100, or
maybe 1024.)

</p>
<h2>No Extra Whitespace</h2>
<p>

If you put extra whitespace in your output, it is a format error.  If we
put it in the input, programs may crash or give wrong output.  So there
will not be any blank lines or spaces in the input that are not mentioned
in the problem definition.  Exactly one space
will be used between input values on a line and there will be no spaces
at the start or end of lines.

</p>
<p>

No tabs.  Not ever.

</p>
<h2>Trivial Input Parsing</h2>
<p>

Unless parsing is the problem (`parse FORTRAN statements' or something
similar), input will be trivial to parse.  You should never need to do
anything more complicated than read in a line, use spaces to divide it
into tokens and figure out which parts are strings and which are numbers.

</p>
<h2>No Equality Comparisons on Reals</h2>
<p>

Any problem that requires floating point equality comparisons on derived
reals is bad.  So we won't do it.  Equality comparisons on numbers that
are known to be equal are fair game.  Some examples:
</p><dl><dt>Known Numbers -- Okay
</dt><dd>Each line of input contains a floating point number and an integer.
	Sort the lines by the floating point number; break ties using the
	integer.
</dd><dt>Derived Numbers -- Bad
</dt><dd>Given a set of points and lines specified by floating point numbers,
	output all of the points that lie on any of the lines.
</dd><dt>Your Fault for Doing It Wrong 1
</dt><dd>The above problem, but with integer coördinates.  There is no need
	to use any floating point numbers.
</dd><dt>Your Fault for Doing It Wrong 2
</dt><dd>Does a line segment intersect a polygon?  We have no problems with making
	the line go through the vertices of the polygon in the test data.
	If you use the easy (and bad) algorithm of checking to see if
	the line goes through any of the lines in the polygon, your program
	might fail.
</dd></dl>

<p></p><p>

Note that there is no excuse for poor computer math.  For example, don't
be tripped up by simple things:
<br>(10<sup>17</sup>-10<sup>17</sup>)+10<sup>-17</sup>=10<sup>-17</sup>
<br>10<sup>17</sup>-(10<sup>17</sup>+10<sup>-17</sup>)=0
<br>10<sup>170</sup>*(10<sup>170</sup>*10<sup>-170</sup>)=10<sup>170</sup>
<br>(10<sup>170</sup>*10<sup>170</sup>)*10<sup>-170</sup>=+Inf
<br>Let's not even think about the horrors of division.

</p>
<h2>Input Number Size</h2>
<p>

Input integers will be at most 2<sup>31</sup>-1, the maximum signed
integer in all of the supported programming languages.

</p>
<h2>Ambiguous Output</h2>
<p>

Problem specifications will mention if there is ambiguous output,
although this might be limited to `output <em>a</em> set
of integers that satisfies the constraints and has minimal size'.

</p>
<h2>Output of Floating Point Numbers</h2>
<p>

This always gets ugly, because some form of rounding will be required.
Just round to the nearest number of the appropriate precision.  The
judges will make sure that floating point error is allowed for so
that you don't need to worry about what happens if you need to round
17.5 to the nearest integer, for example.

</p><p>

As before, if you elect to switch to floating point numbers when
integers would work, any problems that arise are your own.

</p>
</body></html>