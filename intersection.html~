<html><head>
  <meta name="GENERATOR" content="Adobe PageMill 2.0 Mac"><title>Regional Problem Set</title></head>
<body bgcolor="#ffffff">

<h2 align="center">ACM International Collegiate Programming Contest<br>
Southwestern European Regional Contest<br>
ETH Zurich, Switzerland, December 9, 1995</h2>

<p align="center"></p><hr><p></p>

<h1 align="center">Problem Set</h1>

<h2>Contents</h2>

<p><a href="#advice">Rules and Advice</a><br>
<br>
<a href="#intersection">Problem A: Intersection</a><br>
<br>
<a href="#synchronous">Problem B: Synchronous Design</a><br>
<br>
<a href="#coloring">Problem C: Graph Coloring</a><br>
<br>
<a href="#triangle">Problem D: Triangle</a><br>
<br>
<a href="#anagram">Problem E: Anagram</a><br>
<br>
<a href="#spreadsheet">Problem F: Spreadsheet</a><br>
<br>
<a href="#cube">Problem G: Cube</a><br>
<br>
<a href="#calculator">Problem H: Peter's Calculator</a><br>
<br>
<a href="#equation">Problem J: Partial Differential Equations</a><br>
</p>

<p align="center"><b>Sponsored by Microsoft<br>
Supported by Union Bank of Switzerland</b></p>

<p></p><hr><p></p>

<h2><a name="advice"></a>Some Rules and Advice </h2>

<p>All questions require you to read the test data from a single input file
and to write the results to a single output file. The names of both files
are given in the header of the problem. Your are not allowed to read or
write any other files than the specified ones. Standard input and output
are also considered files.<br>
<br>
Output must correspond exactly to the provided sample output, including
spelling and spacing. <br>
<br>
All lines (including the last one) should be terminated with a new-line
character, and no whitespace should appear at the end of a line unless explicitly
specified. Tabs should never be used. <br>
<br>
All programs will be re-compiled prior to testing with the judges' data.
Non-standard libraries may not be used in your solutions. C programs may
not include any files except: <tt>ctype.h</tt>, <tt>math.h</tt>, <tt>stdio.h</tt>,
<tt>stdlib.h</tt>, <tt>string.h</tt>, and <tt>strings.h</tt>. Pascal programs
may use the extended <tt>Reset</tt>, <tt>Rewrite</tt> and the <tt>Close</tt>
statement, which are not part of the ISO Pascal standard.<br>
<br>
After analyzing a program, the judges will send one of the following messages:
</p>

<ul>
  <li><i>Program accepted</i>. Your program passed all tests and is accepted
  as correct. </li>
  <li><i>Compile-time error</i>. The judges were not able to successfully
  compile your program. The compiler returned an error (not just a warning).
  </li>
  <li><i>Run-time error</i>. Your program "crashed", i. e. it exited
  prematurely due to a run-time error. </li>
  <li><i>Wrong answer</i>. The program run through one or more test cases
  without a run-time error but the output did not match the expected output.
  </li>
  <li><i>Presentation error</i>. The output seems to be correct but it is
  not presented in the required format. Since it is not always easy to distinguish
  this message from the <i>wrong answer</i> message, it is only sent in obvious
  cases. </li>
  <li><i>Time-limit exceeded</i>. Your program did not finish within the
  given amount of time. </li>
  <li><i>Contest rule violation</i>. Your program violates a contest rule
  like calling non-standard libraries. </li>
</ul>

<p>Programming style is not considered in this contest. You are free to
code in whatever style you prefer. <br>
<br>
The CPU time limit for all problems is 3 minutes except when specified otherwise.
<br>
<br>
All questions regarding the contest material should be submitted to the
judges by filling in a <i>clarification request</i> form. You can ask the
<i>runners</i> in the room for any non-contest related matters or for getting
your printer output. The helpers will not answer any questions regarding
the contest material. <br>
<br>
Judges' decisions are to be considered final. No cheating will be tolerated.
<br>
<br>
Success! <br>
<br>
</p><hr><p></p>

<h2><a name="intersection"></a>Problem A: Intersection </h2>

<p>Source file: intersection.c / intersection.p<br>
Input file: intersection.in<br>
Output file: intersection.out<br>
<br>
You are to write a program that has to decide whether a given line segment
intersects a given rectangle. </p>

<h4>An example:</h4>

<p>line: start point: (4,9)<br>
end point: (11,2)<br>
rectangle: left-top: (1,5)<br>
right-bottom: (7,1)<br>
<br>
<img src="intersect_files/Intersection.gif" width="217" height="190" naturalsizeflag="0" align="bottom"><br>
<br>
<i>Figure 1: Line segment does not intersect rectangle</i><br>
<br>
The line is said to intersect the rectangle if the line and the rectangle
have at least one point in common. The rectangle consists of four straight
lines and the area in between. Although all input values are integer numbers,
valid intersection points do not have to lay on the integer grid. </p>

<h3>Input</h3>

<p>The input consists of <i>n</i> test cases. The first line of the input
file contains the number <i>n</i>. Each following line contains one test
case of the format: <i>xstart ystart xend yend xleft ytop xright ybottom</i>
where (<i>xstart</i>, <i>ystart</i>) is the start and (<i>xend</i>, <i>yend</i>)
the end point of the line and (<i>xleft</i>, <i>ytop</i>) the top left and
(<i>xright</i>, <i>ybottom</i>) the bottom right corner of the rectangle.
The eight numbers are separated by a blank. The terms <i>top left</i> and
<i>bottom right</i> do not imply any ordering of coordinates. </p>

<h3>Output</h3>

<p>For each test case in the input file, the output file should contain
a line consisting either of the letter "T" if the line segment
intersects the rectangle or the letter "F" if the line segment
does not intersect the rectangle. </p>

<h3>Example</h3>

<h4>Input</h4>

<pre>1
4 9 11 2 1 5 7 1</pre>

<h4>Output</h4>

<pre>F</pre>

<p></p><hr><p></p>

<h2><a name="synchronous"></a>Problem B: Synchronous Design </h2>

<p>Source file: synchronous.c / synchronous.p<br>
Input file: synchronous.in<br>
Output file: synchronous.out<br>
<br>
The designers of digital integrated circuits (IC) are very concerned about
the correctness of their designs because, unlike software, ICs cannot be
easily tested. Real tests are not possible until the design has been finalized
and the IC has been produced.<br>
<br>
To simulate the behavior of a digital IC and to more or less guarantee that
the final chip will work, all of today's digital ICs are based on a <i>synchronous
design</i>. <br>
<br>
<img src="intersect_files/Synchronous1.gif" width="350" height="199" naturalsizeflag="0" align="bottom"><br>
<br>
<i>Figure 1: The critical path (dashed line) takes 43ns to settle</i><br>
<br>
In a synchronous design, an external clock signal triggers the IC to go
from a well defined and stable state to the next one. On the active edge
of the clock, all input and output signals and all internal nodes are stable
in either the high or low state. Between two consecutive edges of the clock,
the signals and nodes are allowed to change and may take any intermediate
state. The behavior of a synchronous network is predictable and will not
fail due to hazards or glitches introduced by irregularities of the real
circuit.<br>
<br>
To analyze whether an IC has a synchronous design, we distinguish between
<i>synchronous</i> and <i>asynchronous nodes</i>. Flip flops are synchronous
nodes. On the active edge of the clock, the output of the flip flop changes
to the state of the input and holds that state throughout the next clock
cycle. Synchronous nodes are connected to the clock signal.<br>
<br>
Simple gates like ANDs or ORs are asynchronous nodes. Their output changes
- with a short delay - whenever one of their inputs changes. During that
transition phase, the output can even go into some undefined or intermediate
state.<br>
<br>
For simplicity, we assume that all inputs of the circuits are directly connected
to the output of a synchronous node outside the circuit and that all outputs
of the circuit are directly connected to the input of a synchronous node
outside the circuit. <br>
<br>
For an IC to have a synchronous design, mainly two requirements must be
met: </p>

<ul>
  <li>The <i>signal delay</i> introduced between two synchronous nodes must
  be smaller or equal than the clock period so there is enough time for nodes
  to become stable. In figure 1, the round-ended boxes are asynchronous nodes
  whereas the square boxes are synchronous nodes. The delay introduced on
  the dashed path is 43ns and exceeds the given clock period of 30ns. </li>
  <li>There may be <i>no cycles</i> composed exclusively of asynchronous
  nodes. In the real circuit such cycles could oscillate. In figure 2, the
  dashed path constitutes a cycle of asynchronous nodes. </li>
</ul>

<p>Figure 3 shows a circuit with a synchronous design. It does not contain
cycles composed of asynchronous nodes and the longest path between two synchronous
nodes is shorter than the clock period of 30ns. <br>
<br>
<img src="intersect_files/Synchronous2.gif" width="350" height="217" naturalsizeflag="0" align="bottom"><br>
<br>
<i>Figure 2: The design contains a cycle (dashed line)</i><br>
<br>
<img src="intersect_files/Synchronous3.gif" width="350" height="200" naturalsizeflag="0" align="bottom"><br>
<br>
<i>Figure 3: A synchronous design</i><br>
<br>
Your are to write a program that decides for a given IC whether it has a
synchronous design or not. You are given a network of synchronous and asynchronous
nodes, a delay for each node, some inputs and outputs and the clock period.<br>
<br>
You may safely assume that </p>

<ul>
  <li>the delays introduced between any input and any output of the same
  node are equal, i.e. equal to the delay given for that node, </li>
  <li>synchronous nodes have no delay at all, </li>
  <li>all connections between two nodes connect an output to an input. </li>
</ul>

<h3>Input</h3>

<p>The input file contains several circuits. The first line gives the number
of circuits in the file.<br>
<br>
For each circuit in the file, the first line contains the clock period for
the circuit, given as an integer number in nanoseconds. The next line gives
the number of nodes. The following lines each contain a node, described
by a letter and a integer number. The letter is 'i' for an input, 'o' for
an output, 'a' for an asynchronous node and 's' for a synchronous node.
The number gives the delay introduced by the node as an integer number in
nanoseconds (only meaningful for an asynchronous node). Nodes are implicitly
numbered, starting at zero.<br>
<br>
After the nodes, the number of connections for the circuit follows. Each
following line contains a pair of integer numbers denoting a connection
between the output and the input of two nodes. The connection links an output
of the node given by the first number and an input of the node given by
the second number.<br>
<br>
The clock signal is not given in the input file. We assume that all synchronous
nodes are properly connected to the clock signal. </p>

<h3>Output</h3>

<p>For each circuit in the input file, your output file should contain a
line with one of the following messages: </p>

<ul>
  <li>"<tt>Synchronous design. Maximum delay: &lt;<i>ss</i>&gt;.</tt>"
  if the circuit has a synchronous design. &lt;<i>ss</i>&gt; should be replaced
  by the longest delay found on any path between two synchronous nodes. </li>
  <li>"<tt>Circuit contains cycle.</tt>" if the circuit contains
  a cycle composed exclusively of asynchronous nodes. </li>
  <li>"<tt>Clock period exceeded."</tt> if there is a path between
  two synchronous nodes that is longer than the given clock period and there
  are no cycles composed of asynchronous nodes. </li>
</ul>

<h3>Example</h3>

<h4>Input</h4>

<pre>1
30
10
i 0
i 0
i 0
i 0
o 0
o 0
a 9
a 11
a 8
s 0
9
0 8
1 7
2 6
2 6
6 7
7 8
8 4
7 9
9 5</pre>

<h4>Output</h4>

<pre>Synchronous design. Maximum delay: 28</pre>

<p></p><hr><p></p>

<h2><a name="coloring"></a>Problem C: Graph Coloring </h2>

<p>Source file: coloring.c / coloring.p<br>
Input file: coloring.in<br>
Output file: coloring.out<br>
<br>
You are to write a program that tries to find an optimal coloring for a
given graph. Colors are applied to the nodes of the graph and the only available
colors are black and white. The coloring of the graph is called optimal
if a maximum of nodes is black. The coloring is restricted by the rule that
no two connected nodes may be black. <br>
<br>
<img src="intersect_files/Coloring.gif" width="217" height="145" naturalsizeflag="0" align="bottom"><br>
<br>
<i>Figure 1: An optimal graph with three black nodes</i> </p>

<h3>Input</h3>

<p>The graph is given as a set of nodes denoted by numbers 1...<i>n</i>,
<i>n</i> &lt;= 100, and a set of undirected edges denoted by pairs
of node numbers (<i>n</i>1, <i>n</i>2), <i>n</i>1 != <i>n</i>2. The
input file contains <i>m</i> graphs. The number <i>m</i> is given on the
first line. The first line of each graph contains <i>n</i> and <i>k</i>,
the number of nodes and the number of edges, respectively. The following
<i>k</i> lines contain the edges given by a pair of node numbers, which
are separated by a space. </p>

<h3>Output</h3>

<p>The output should consists of 2<i>m</i> lines, two lines for each graph
found in the input file. The first line of should contain the maximum number
of nodes that can be colored black in the graph. The second line should
contain one possible optimal coloring. It is given by the list of black
nodes, separated by a blank. </p>

<h3>Example</h3>

<h4>Input</h4>

<pre>1
6 8
1 2
1 3
2 4
2 5
3 4
3 6
4 6
5 6</pre>

<h4>Output</h4>

<pre>3
1 4 5</pre>

<p></p><hr><p></p>

<h2><a name="triangle"></a>Problem D: Triangle </h2>

<p>Source file: triangle.c / triangle.p<br>
Input file: triangle.in<br>
Output file: triangle.out<br>
<br>
A triangle is a basic shape of planar geometry. It consists of three straight
lines and three angles in between. Figure 1 shows how the sides and angles
are usually labeled. <br>
<br>
<img src="intersect_files/Triangle.gif" width="262" height="172" naturalsizeflag="0" align="bottom"><br>
<br>
<i>Figure 1: Triangle</i><br>
<br>
A look into a book about geometry shows that many formulas for triangles
exist: <br>
</p>

<p align="center"><img src="intersect_files/TriEqu1.gif" width="69" height="15" naturalsizeflag="0" align="bottom"><br>
<br>
<img src="intersect_files/TriEqu2.gif" width="103" height="31" naturalsizeflag="0" align="bottom"><br>
<br>
<img src="intersect_files/TriEqu3.gif" width="96" height="15" naturalsizeflag="0" align="bottom"><br>
<br>
<img src="intersect_files/TriEqu4.gif" width="116" height="15" naturalsizeflag="0" align="bottom"><br>
<br>
<img src="intersect_files/TriEqu5.gif" width="143" height="30" naturalsizeflag="0" align="bottom"></p>

<p>The values of <i>a</i>, <i>b</i>, <i>c</i>, <i>alpha</i>, <i>beta</i>,
and <i>gamma</i> form a set of six parameters that fully define a triangle.
If a large enough subset of these parameters is given, the missing ones
can be calculated by using the formulas above.<br>
<br>
You are to write a program that calculates the missing parameters for a
given subset of the six parameters of a triangle. For some sets of parameters,
it is not possible to calculate the triangle because either too few is known
about the triangle or the parameters would lead to an invalid triangle.
The sides of a valid triangle are greater than 0 and the angles are greater
than 0 and less than pi. Your program should detect this case and output:
"<tt>Invalid input.</tt>" The same phrase should be output if
more than the minimal set needed to compute the triangle is given but the
parameters conflict with each other, e.g. all three angles are given but
their sum is greater than pi.<br>
<br>
Other sets of parameters can lead to more than one but still a finite number
of valid solutions for the triangle. In such a case, your program should
output: "<tt>More than one solution.</tt>"<br>
<br>
In all other cases, your program should compute the missing parameters and
output all six parameters. </p>

<h3>Input</h3>

<p>The first line of the input file contains a number indicating the number
of parameter sets to follow. Each following line consists of six numbers,
separated by a single blank character. The numbers are the values for the
parameters <i>a</i>, <i>alpha</i>, <i>b</i>, <i>beta</i>, <i>c</i>, and
<i>gamma</i> respectively. The parameters are labeled as shown in figure
1. A value of -1 indicates that the corresponding parameter is undefined
and has to be calculated. All floating-point numbers include at least eight
significant digits. </p>

<h3>Output</h3>

<p>Your program should output a line for each set of parameters found in
the input file. If a unique solution for a valid triangle can be found for
the given parameters, your program should output the six parameters a<i>,</i>
<i>alpha</i>, <i>b</i>, <i>beta</i>, <i>c</i>, <i>gamma</i>, separated by
a blank character. Otherwise the line should contain the phrase "<tt>More
than one solution.</tt>" or "<tt>Invalid input.</tt>" as
explained above.<br>
<br>
The numbers in the output files should include at least eight significant
digits. Your calculations should be precise enough to get the six most significant
digits correct. </p>

<h3>Example</h3>

<h4>Input</h4>

<pre>3
62.72048064 2.26853639 -1.00000000 0.56794657 -1.00000000 -1.00000000
15.69326944 0.24714213 -1.00000000 1.80433105 66.04067877 -1.00000000
72.83685175 1.04409241 -1.00000000 -1.00000000 -1.00000000 -1.00000000</pre>

<h4>Output</h4>

<pre>62.72048064 2.26853639 44.02668698 0.56794657 24.58722491 0.30510970
Invalid input.
Invalid input.</pre>

<p></p><hr><p></p>

<h2><a name="anagram"></a>Problem E: Anagram </h2>

<p>Source file: anagram.c / anagram.p<br>
Input file: anagram.in<br>
Output file: anagram.out<br>
<br>
You are to write a program that has to generate all possible words from
a given set of letters. </p>

<h4>Example</h4>

<p>Given the word "abc", your program should - by exploring all
different combination of the three letters - output the words "abc",
"acb", "bac", "bca", "cab" and "cba".<br>
<br>
In the word taken from the input file, some letters may appear more than
once. For a given word, your program should not produce the same word more
than once, and the words should be output in alphabetically ascending order.
</p>

<h3>Input</h3>

<p>The input file consists of several words. The first line contains a number
giving the number of words to follow. Each following line contains one word.
A word consists of uppercase or lowercase letters from A to Z. Uppercase
and lowercase letters are to be considered different. </p>

<h3>Output</h3>

<p>For each word in the input file, the output file should contain all different
words that can be generated with the letters of the given word. The words
generated from the same input word should be output in alphabetically ascending
order. </p>

<h3>Example</h3>

<h4>Input</h4>

<pre>2
abc
acba</pre>

<h4>Output</h4>

<pre>abc
acb
bac
bca
cab
cba
aabc
aacb
abac
abca
acab
acba
baac
baca
bcaa
caab
caba
cbaa</pre>

<h3>Hint</h3>

<p>The number of possible combinations raises very quickly with the number
of given letters. Make sure you do not use long words for testing your program
because the output file could become very big, waste a lot of space on the
disk and degrade the performance of the network. <br>
<br>
</p><hr><p></p>

<h2><a name="spreadsheet"></a>Problem F: Spreadsheet </h2>

<p>Source file: spreadsheet.c / spreadsheet.p<br>
Input file: spreadsheet.in<br>
Output file: spreadsheet.out<br>
<br>
In 1979, Dan Bricklin and Bob Frankston wrote VisiCalc, the first spreadsheet
application. It became a huge success and, at that time, was the killer
application for the Apple II computers. Today, spreadsheets are found on
most desktop computers.<br>
<br>
The idea behind spreadsheets is very simple, though powerful. A spreadsheet
consists of a table where each cell contains either a number or a formula.
A formula can compute an expression that depends on the values of other
cells. Text and graphics can be added for presentation purposes.<br>
<br>
You are to write a very simple spreadsheet application. Your program should
accept several spreadsheets. Each cell of the spreadsheet contains either
a numeric value (integers only) or a formula, which only support sums. After
having computed the values of all formulas, your program should output the
resulting spreadsheet where all formulas have been replaced by their value.
</p>

<pre> A1    B1     C1     D1     E1     F1     ...    
 A2    B2     C2     D2     E2     F2     ...    
 A3    B3     C3     D3     E3     F3     ...    
 A4    B4     C4     D4     E4     F4     ...    
 A5    B5     C5     D5     E5     F5     ...    
 A6    B6     C6     D6     E6     F6     ...    
 ...   ...    ...    ...    ...    ...    ...    </pre>

<p><i>Figure 1: Naming of the top left cells</i> </p>

<h3>Input</h3>

<p>The first line of the input file contains the number of spreadsheets
to follow. A spreadsheet starts with a line consisting of two integer numbers,
separated by a space, giving the number of columns and rows. The following
lines of the spreadsheet each contain a row. A row consists of the cells
of that row, separated by a single space.<br>
<br>
A cell consists either of a numeric integer value or of a formula. A formula
starts with an equal sign (=). After that, one or more cell names follow,
separated by plus signs (+). The value of such a formula is the sum of all
values found in the referenced cells. These cells may again contain a formula.
There are no spaces within a formula.<br>
<br>
You may safely assume that there are no cyclic dependencies between cells.
So each spreadsheet can be fully computed.<br>
<br>
The name of a cell consists of one to three letters for the column followed
by a number between 1 and 999 (including) for the row. The letters for the
column form the following series: A, B, C, ..., Z, AA, AB, AC, ..., AZ,
BA, ..., BZ, CA, ... ZZ, AAA, AAB, AAC, ... AAZ, ABA, ..., ABZ, ACA, ...,
ZZZ. These letters correspond to the number from 1 to 18278. The top left
cell has the name A1. See figure 1. </p>

<h3>Output</h3>

<p>The output of your program should have the same format as the input,
except that the number of spreadsheets and the number of columns and rows
are not repeated. Furthermore, all formulas should be replaced by their
value. </p>

<h3>Example</h3>

<h4>Input</h4>

<pre>1
4 3
10 34 37 =A1+B1+C1
40 17 34 =A2+B2+C2
=A1+A2 =B1+B2 =C1+C2 =D1+D2</pre>

<h4>Output</h4>

<pre>10 34 37 81
40 17 34 91
50 51 71 172</pre>

<p></p><hr><p></p>

<h2><a name="cube"></a>Problem G: Cube </h2>

<p>Source file: cube.c / cube.p<br>
Input file: <i>None</i><br>
Output file: cube.out<br>
<br>
There was once a 3 by 3 by 3 cube built of 27 smaller cubes. It has fallen
apart into seven pieces: <br>
<br>
<img src="intersect_files/Cube1.gif" width="350" height="181" naturalsizeflag="0" align="bottom"><br>
<br>
<i>Figure 1: The seven pieces that once formed a cube</i><br>
<br>
The seven pieces can be assembled in many ways to again form the cube. Figure
2 shows one of these possibilities. The first square stands for the front
plane, the next one for the middle plane and the last one for the back plane
of the cube. The letters in the cells stand for the name of piece filling
out the corresponding space in the cube. The name of the seven pieces can
be found in figure 1. </p>

<pre>a   d   c      d   d   g      d   g   g   
a   c   c      b   f   g      b   f   e   
a   a   c      f   f   e      b   e   e   


a   a   b      f   f   e      f   e   e   
a   b   b      g   f   c      g   g   e   
a   d   c      d   d   c      d   g   c   </pre>

<p><i>Figure 2: Two possibilities of assembling the cube</i><br>
<br>
You are to write a program that outputs all possibilities of assembling
the cube but suppress solutions that are mere rotations of another solution.
The time limit for this problem is 15 minutes! </p>

<h3>Input</h3>

<p>No input is needed. </p>

<h3>Output</h3>

<p>For each solution found, your program should output a line containing
the solution as a string. The string is a linearized form of the cube. Each
letter stands for the piece filling out the corresponding space in the cube.
It is linearized as follows: </p>

<ul>
  <li>The string consists of substrings representing the front, middle and
  back plane. </li>
  <li>Each substring consists of substrings representing the top, middle
  and bottom row. </li>
  <li>Each row substring consists of letters representing the left, middle
  and right cell. </li>
</ul>

<p>The solutions in figure 2 would be represented like this: </p>

<pre>adcaccaacddgbfgffedggbfebee
aababbadcffegfcddcfeeggedgc</pre>

<p>It is very important that your program uses the naming convention given
in figure 1 and linearizes the cube as explained above. <br>
<br>
<img src="intersect_files/Cube2.gif" width="300" height="213" naturalsizeflag="0" align="bottom"><br>
<br>
<i>Figure 3: Positions of the cells in the string </i><br>
<br>
Figure 3 again shows how the cells of the cube are linearized. </p>

<h3>Example</h3>

<p>The output of your program could start like this: </p>

<pre>aababbadcggeffcddcgeegfedfc
aababbadceffgdcgdceefedfggc
aababbadcffegfcddcfeeggedgc
...</pre>

<h3>Hint</h3>

<p>Piece <i>a</i> is the only part that, by rotation and translation, cannot
be transformed into itself. In order to avoid solutions that are mere rotations
of an already found solution, you may restrict transformations of piece
<i>a</i> to translations. <br>
<br>
</p><hr><p></p>

<h2><a name="calculator"></a>Problem H: Peter's Calculator </h2>

<p>Source file: calculator.c / calculator.p<br>
Input file: calculator.in<br>
Output file: calculator.out<br>
<br>
Unfortunately, Peter's Calculator broke down last week. Now Peter is left
with his computer, which has no calculator application, and paper and pencil,
which is too tiresome for an engineer. As one of Peter's friends, you are
asked to write him a calculator application. After talking to him, you figure
out the following: </p>

<ul>
  <li>Peter does only integer arithmetic. The operations he needs are addition,
  subtraction and multiplication. </li>
  <li>He would like to use an arbitrary number of variables whose names are
  not longer than 50 characters. </li>
  <li>His main way of doing calculations are to type in a few formulas and
  to assign them to variables. Some formulas are complicated expressions,
  which can refer to yet undefined variables, while other formulas consist
  of a single number. Then Peter asks for the value of some variables, i.e.
  he evaluates the formulas. </li>
  <li>Peters wants to redefine some variables and then to reevaluate formulas
  that depend on these variables. </li>
</ul>

<p>The input strictly adheres to the following syntax (given in EBNF): </p>

<pre>file = line { line } &lt;EOF&gt;.
line = [ assignment | print | reset ] &lt;CR&gt;.
assignment = var ":=" expression.
print = "PRINT" var.
reset = "RESET".
expression = term { addop term }.
term = factor { mulop factor }.
factor = "(" expression ")" | var | number.
addop = "+" | "-".
mulop = "*". </pre>

<p>In the Extended Backus-Naur Formalism (EBNF), <tt>A = B C</tt> declares
that the grammatical construct <tt>A</tt> consists of a <tt>B</tt> followed
by a <tt>C</tt>. <tt>A = B | C</tt> means that <tt>A</tt> consists of a
<tt>B</tt> or, alternatively, of a <tt>C</tt>. <tt>A = [ B ]</tt> defines
construct <tt>A</tt> to be either a <tt>B</tt> or nothing and <tt>A = {
B }</tt> tells you that <tt>A</tt> consists of the concatenation of any
number of <tt>B</tt>s (including none).<br>
<br>
The production <tt>var</tt> stands for the name of a variable, which starts
with a letter followed by up to 49 letters or digits. Letters may be uppercase
or lowercase. The production <tt>number</tt> stands for a integer number.
The precise syntax for these productions are given below. The case of letters
is important for both variables and statements. </p>

<pre>var = letter { letter | digit }.
number = [ "-" ] digit { digit }.
letter = "A" | "B" | ... | "Z" | "a" | "b" | ... | "z".
digit = "0" | "1" | ... | "8" | "9".</pre>

<p>Between the parts of a grammatical construct but not within the names
of variables or integer numbers, any number of spaces may appear. &lt;EOF&gt;
stands for the end of the input file and &lt;CR&gt; stands for the new-line
character. All lines in the input file are shorter than 200 characters.<br>
<br>
The value of a variable is said to be undefined: </p>

<ul>
  <li>if it has not yet been defined or it refers to a variable, which has
  not yet been defined; </li>
  <li>if the definition of the variable contains a cycle. </li>
</ul>

<p>Your are to write a program that implements Peter's calculator. It should
store all variable definitions and for each "PRINT" statement
evaluate the specified variable based on the latest variable definitions.
If your program encounters a "RESET" statement, it should delete
all stored variables so that all variables become undefined. </p>

<h3>Input</h3>

<p>The input file contains calculations adhering to the syntax given above.
Each line contains either an assignment to a variable, a "PRINT"
statement, a "RESET" statement or nothing. </p>

<h3>Output</h3>

<p>For each "PRINT" statement found in the input file, your program
should output a line containing the numerical value of the specified variable
or the word "UNDEF" if the variable is undefined. </p>

<h3>Example</h3>

<h4>Input</h4>

<pre>a := b + c
b := 3
c := 5
PRINT d
PRINT a
b := 8
PRINT a
RESET
PRINT a</pre>

<h4>Output</h4>

<pre>UNDEF
8
13
UNDEF</pre>

<p></p><hr><p></p>

<h2><a name="equation"></a>Problem J: Partial differential equations </h2>

<p>Source file: equation.c / equation.p<br>
Input file: equation.in<br>
Output file: equation.out<br>
<br>
In engineering sciences, partial differential equations play an important
and central role. For example, the temperature of a metal plate can be expressed
as a partial differential equation if the temperature on the boundaries
is known. This is called a boundary value problem.<br>
<br>
Usually, it is not easy to solve these problems. Analytical solutions exist
only in very special cases. But there are some more or less "good"
numerical ways to solve boundary value problems.<br>
<br>
We now will look at one method which works with finite difference approximations
for the derivatives of a function. For this approach, we do not look at
an analytical function <i>u</i>(<i>x</i>) but we are only interested in
the values of <i>u</i> at a finite set of discrete points <i>x<sub>i</sub></i>:
<i>u<sub>i</sub></i> = <i>u</i>(<i>xi</i>). The distance between two adjacent
points, <i>x<sub>i</sub></i> and <i>x<sub>i</sub></i>+1, is constant: <i>h</i>
= <i>x<sub>i</sub></i><sub>+1</sub> - <i>x<sub>i</sub></i> (cf. figure 1). <br>
<br>
<img src="intersect_files/Equation1.gif" width="450" height="231" naturalsizeflag="0" align="bottom"><br>
<br>
<i>Figure 1: u(x) at some discrete points x<sub>i</sub></i><br>
<br>
The finite difference approximation of a first derivative of the function
<i>u</i>(<i>x</i>) is <br>
</p>

<p align="center"><img src="intersect_files/EquEqu1.gif" align="middle" width="117" height="33" naturalsizeflag="0">(1) </p>

<p>The second derivative is approximated by <br>
</p>

<p align="center"><img src="intersect_files/EquEqu2.gif" align="middle" width="141" height="36" naturalsizeflag="0">(2) </p>

<p>This approximation works with 2-dimensional functions <i>u</i>(<i>x</i>,
<i>y</i>) as well. For simplicity we only work on square problems, i.e.
(<i>x</i>, <i>y</i>) is element of [0,1] x [0,1]. Again, the area of the
function is discretized in a similar way: <i>x<sub>i</sub></i><sub>+1</sub> - <i>x<sub>i</sub></i>
= <i>y<sub>i</sub></i><sub>+1</sub> - <i>y<sub>i</sub></i> = <i>h</i> = 1 / <i>n</i>,
for some integer <i>n</i> &gt;= 2. We only look at the values of <i>u</i>(<i>x</i>,
<i>y</i>) at the discrete points <i>P<sub>k</sub></i> = (<i>x<sub>i</sub></i>,
<i>y<sub>j</sub></i>): <i>u<sub>i</sub></i><sub>,<i>j</i></sub> = <i>u</i>(<i>P<sub>k</sub></i>).
With this discretization, we have a function <i>u<sub>i</sub></i><sub>,<i>j</i></sub>
as shown in figure 2: <br>
<br>
<img src="intersect_files/Equation2.gif" width="400" height="377" naturalsizeflag="0" align="bottom"><br>
<br>
<i>Figure 2: Function u<sub>i,j</sub> in the discretization area</i><br>
<br>
On the boundary, <i>u</i>(<i>x<sub>i</sub></i>, <i>y<sub>j</sub></i>) is
given by 4 known functions: <br>
</p>

<p align="center"><img src="intersect_files/EquEqu3.gif" align="middle" width="79" height="63" naturalsizeflag="0">(3) </p>

<p>The points <i>P<sub>k</sub></i> cover the inner points of the discretization
area, i.e. the area without the boundary. They are numbered from left to
right and from top to bottom like English text. <br>
<br>
What we now want to do is to solve the poisson-equation in the area [0,1]
x [0,1]: <br>
</p>

<p align="center"><img src="intersect_files/EquEqu4.gif" align="middle" width="112" height="33" naturalsizeflag="0">(4) </p>

<p>with the above boundary conditions. <i>f</i>(<i>x</i>, <i>y</i>) is a
given 2-dimensional function. With equation (2) and the above discretization,
the poisson-equation can be approximated at <br>
</p>

<p align="center"><img src="intersect_files/EquEqu5.gif" align="middle" width="199" height="27" naturalsizeflag="0">, (5) </p>

<p>where <i>f<sub>i</sub></i><sub>,<i>j</i></sub> is the function <i>f</i>(<i>x</i>,
<i>y</i>), evaluated at the discrete points (<i>x<sub>i</sub></i>, <i>y<sub>j</sub></i>).
<br>
<br>
Formula (5) can be written in a more readable form, depending on the position
of the discrete points: <br>
</p>

<p align="center"><img src="intersect_files/EquEqu6a.gif" align="middle" width="177" height="53" naturalsizeflag="0">(6a) </p>

<p>A similar equation, which we will use as an example below, is: <br>
</p>

<p align="center"><img src="intersect_files/EquEqu6b.gif" align="middle" width="178" height="53" naturalsizeflag="0">(6b) </p>

<p>We call the 3x3 matrix on the left hand side <i>v</i> and the 3x3 matrix
on the right hand side <i>g</i>. Now, equation (6b) can be formulated in
every point of the discrete area of figure 2:<br>
</p>

<p align="center"><img src="intersect_files/EquEqu7.gif" align="middle" width="432" height="69" naturalsizeflag="0">(7) </p>

<p>(7) is a linear equation system for the values of <i>u</i>(<i>x</i>,
<i>y</i>) at the points <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, <i>P</i><sub>3</sub>
and <i>P</i><sub>4</sub>.<br>
<br>
By rearranging and adding the terms on each line, the linear equation system
can be formulated as: <br>
</p>

<p align="center"><i>az</i> = <i>b</i> (8) </p>

<p>where <i>a</i> is a 4x4 matrix and b is a vector with 4 elements. Vector
<i>z</i> represents the unknown values of <i>u</i>(<i>x</i>, <i>y</i>) at
the points <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, <i>P</i><sub>3</sub>
and <i>P</i><sub>4</sub>. <br>
<br>
You are to write a program that creates the linear equation system (7) in
the form (8) for any two matrices <i>v</i> and <i>g</i> (6). As input, the
two matrices <i>v</i> and <i>g</i> and the functions <i>b</i><sub>1</sub>,
<i>b</i><sub>2</sub>, <i>b</i><sub>3</sub>, <i>b</i><sub>4</sub>, and <i>f</i>
are given. Also, a parameter <i>n</i> is given as the number of discretization
intervals. Thus, h = 1/n. As the result, your program should calculate the
matrix <i>a</i> and the vector <i>b</i>. For this more general case, there
are (<i>n</i>-1)<sup>2</sup> inner points and <i>a</i> and <i>b</i> must
be sized accordingly. </p>

<h3>Input</h3>

<p>The input file consists of <i>m</i> tests. The number <i>m</i> is given
in the first line of the file. The first line of each test contains the
number <i>n</i> which gives the number of discretizations intervals as defined
above. You may assume that 2 &lt;= n &lt;= 30. Then the 3x3 matrices <i>v</i>
and <i>g</i> follow. The following four lines contain the functions <i>b</i><sub>1</sub>,
<i>b</i><sub>2</sub>, <i>b</i><sub>3</sub> and <i>b</i><sub>4</sub>, each
given as a vector of order <i>n</i>+1, containing the values for 0, <i>h</i>,
2<i>h</i>, ..., 1. Finally, the function <i>f</i> is given as a n+1 by n+1
matrix. Like the vectors before, it contains the values for <i>x</i>, <i>y</i>
= 0, <i>h</i>, 2<i>h</i>, ..., 1. Each row contains from left to right the
function values for increasing <i>x</i> values while each column contains
from top to bottom the function values for increasing <i>y</i> values. <br>
<br>
A vector occupies one line. Its values are given in ascending order, separated
by a space. A <i>n</i> by <i>n</i> matrix occupies <i>n</i> lines. Its rows
are given in ascending order as vectors, which occupy one line each. All
values found in the input file are integer values. </p>

<h3>Output</h3>

<p>For each test found in the input file, your program should output the
matrices <i>a</i> and <i>b</i>. Matrix <i>a</i> is a (<i>n</i>-1)<sup>2</sup>
x (<i>n</i>-1)<sup>2 </sup>matrix (the discretization area (cf. figure 2)
contains (<i>n</i>-1)<sup>2 </sup>inner points, which are unknown). The
vector <i>b</i> is of order (<i>n</i>-1)<sup>2</sup>. They should be output
in the same format as the vectors and matrices in the input file. Your output
should only contain integer values. Note that the expression 1 / <i>h</i><sup>2</sup>
yields an integer number and that all other calculations can also be done
using integer numbers. </p>

<h3>Example</h3>

<h4>Input</h4>

<pre>1
3
1 0 2
0 -4 0
3 0 4
0 5 0
6 0 7
0 8 0
3 4 5 6
0 1 2 3
3 2 1 0
6 5 4 3
1 1 1 1
2 2 2 2
3 3 3 3
4 4 4 4</pre>

<h4>Output</h4>

<pre>-36 0 0 36
0 -36 27 0
0 18 -36 0
9 0 0 -36
-8 -152 -198 -333</pre>
</body></html>